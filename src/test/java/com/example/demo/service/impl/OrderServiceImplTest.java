package com.example.demo.service.impl;

import com.example.demo.entity.Order;
import com.example.demo.entity.User;
import com.example.demo.exception.UserNotFoundException;
import com.example.demo.model.OrderDTO;
import com.example.demo.repository.OrderRepository;
import com.example.demo.repository.UserRepository;
import com.example.demo.service.OrderService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

@ExtendWith(MockitoExtension.class) // annotation that tells JUnit to use Mockito for this test class. Mockito won't work without this.
class OrderServiceImplTest { // test class for OrderServiceImpl, needs *Test suffix to be recognized by JUnit. No need to be public, same for test methods.

    private static final long USER_ID = 12345L;
    private static final String ORDER_DESCRIPTION = "fake description";

    @Mock // annotation that tells Mockito to create a mock (fake/simulated) object of the OrderRepository class
    private OrderRepository orderRepository;

    @Mock
    private UserRepository userRepository;

    @Mock
    private User user;

    private OrderService orderService;

    @BeforeEach // annotation that tells JUnit to run this method before each test method
    void setUp() {
        // since we implemented the service with Spring constructor dependency injection,
        // it gets simple to pass the mocked objects to the constructor in order to manually create an instance.
        orderService = new OrderServiceImpl(orderRepository, userRepository);
    }

    /**
     * method that should test the {@link OrderServiceImpl::findAllOrders(long)} method
     */
    @Test
    void findAllOrders() { // TBD
    }

    /**
     * method that tests the {@link OrderServiceImpl#placeOrder(long, OrderDTO)} method on the happy path
     */
    @Test // annotation that tells JUnit this is a method that executes a test
    void placeOrder() {
        // first line in OrderServiceImpl::placeOrder is searching the user in db,
        // so we are mocking (controlling its behaviour) the userRepository::findById method to return what we want when id 12345L is used as argument,
        // return an Optional<User> object with our fake User object (user) inside
        Mockito.when(userRepository.findById(USER_ID)) // USER_ID means 12345L - see above defined constant
                .thenReturn(Optional.of(user));

        // create a dummy/fake OrderDTO object to be used as an argument for the OrderServiceImpl::placeOrder method
        OrderDTO orderDTO = new OrderDTO(null, ORDER_DESCRIPTION); // no id needed as we know it will be generated by the db

        // create a dummy/fake Order object to be returned by the orderRepository::save method
        Order savedOrderInDB = new Order("different fake db description", user); // use a different description to avoid confusion of returned object from db
        savedOrderInDB.setId("fake db order id"); // add also a fake id (as it will be generated by the db)

        // we want to return our own fake Order object defined above (savedOrderInDB),
        // when we are saving in db an order with description "fake db description" - see constant ORDER_DESCRIPTION
        // this way we ensure that we are getting back the db object after 'save' operation
        Mockito.when(orderRepository.save(Mockito.argThat(ord ->
                        ORDER_DESCRIPTION.equals(ord.getDescription()))))
                .thenReturn(savedOrderInDB);

        // we call the method we want to test with the arguments handled above. This returns a new OrderDTO object
        OrderDTO placedOrder = orderService.placeOrder(USER_ID, orderDTO);

        // we check that our returned OrderDTO (converted from Order entity) has the same id and description as the savedOrderInDB
        assertEquals("fake db order id", placedOrder.id());
        assertEquals("different fake db description", placedOrder.description());
    }

    /**
     * method that tests the {@link OrderServiceImpl#placeOrder(long, OrderDTO)} method
     * when the user is not found in db
     */
    @Test
    void placeOrder_userNotFound() {
        // we are mocking the userRepository::findById method to return an empty Optional<User> object - meaning the user is not found in db
        Mockito.when(userRepository.findById(USER_ID))
                .thenReturn(Optional.empty());

        // calling the method we want to test with the argument handled above - 12345L - see USER_ID constant,
        // we expect that a UserNotFoundException is thrown because the user is not found in db
        UserNotFoundException exception = assertThrows(UserNotFoundException.class,
                () -> orderService.placeOrder(USER_ID, null)); // no need to pass a valid OrderDTO object in this case, as the exception will be thrown before the object is used

        // we check that various properties of the exception are the same as we expect
        assertEquals("404 NOT_FOUND \"I can't find user with id: 12345\"", exception.getMessage());
        assertEquals(HttpStatus.NOT_FOUND, exception.getStatusCode());
    }

    /**
     * method that should test the {@link OrderServiceImpl#findOrdersByDescription(String)} method
     */
    @Test
    void findOrdersByDescription() { // TBD
    }
}